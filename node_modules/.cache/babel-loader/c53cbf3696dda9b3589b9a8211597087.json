{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _result = _interopRequireDefault(require(\"./result\"));\n\nvar _util = require(\"./internal/util\");\n\nvar _connectionHolder = _interopRequireWildcard(require(\"./internal/connection-holder\"));\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\n\nvar _streamObservers = require(\"./internal/stream-observers\");\n\nvar _error = require(\"./error\");\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Represents a transaction in the Neo4j database.\r\n *\r\n * @access public\r\n */\n\n\nvar Transaction = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\r\n   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\r\n   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\r\n   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\r\n   * is not yet released.\r\n   * @param {boolean} reactive whether this transaction generates reactive streams\r\n   * @param {number} fetchSize - the record fetch size in each pulling batch.\r\n   */\n  function Transaction(_ref) {\n    var connectionHolder = _ref.connectionHolder,\n        onClose = _ref.onClose,\n        onBookmark = _ref.onBookmark,\n        onConnection = _ref.onConnection,\n        reactive = _ref.reactive,\n        fetchSize = _ref.fetchSize;\n    (0, _classCallCheck2[\"default\"])(this, Transaction);\n    this._connectionHolder = connectionHolder;\n    this._reactive = reactive;\n    this._state = _states.ACTIVE;\n    this._onClose = onClose;\n    this._onBookmark = onBookmark;\n    this._onConnection = onConnection;\n    this._onError = this._onErrorCallback.bind(this);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._fetchSize = fetchSize;\n    this._results = [];\n  }\n\n  (0, _createClass2[\"default\"])(Transaction, [{\n    key: \"_begin\",\n    value: function _begin(bookmark, txConfig) {\n      var _this = this;\n\n      this._connectionHolder.getConnection().then(function (conn) {\n        _this._onConnection();\n\n        return conn.protocol().beginTransaction({\n          bookmark: bookmark,\n          txConfig: txConfig,\n          mode: _this._connectionHolder.mode(),\n          database: _this._connectionHolder.database(),\n          beforeError: _this._onError,\n          afterComplete: _this._onComplete\n        });\n      })[\"catch\"](function (error) {\n        return _this._onError(error);\n      });\n    }\n    /**\r\n     * Run Cypher query\r\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\r\n     * or with the query and parameters as separate arguments.\r\n     * @param {mixed} query - Cypher query to execute\r\n     * @param {Object} parameters - Map with parameters to use in query\r\n     * @return {Result} New Result\r\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(query, parameters) {\n      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),\n          validatedQuery = _validateQueryAndPara.validatedQuery,\n          params = _validateQueryAndPara.params;\n\n      var result = this._state.run(validatedQuery, params, {\n        connectionHolder: this._connectionHolder,\n        onError: this._onError,\n        onComplete: this._onComplete,\n        onConnection: this._onConnection,\n        reactive: this._reactive,\n        fetchSize: this._fetchSize\n      });\n\n      this._results.push(result);\n\n      return result;\n    }\n    /**\r\n     * Commits the transaction and returns the result.\r\n     *\r\n     * After committing the transaction can no longer be used.\r\n     *\r\n     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\r\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var committed = this._state.commit({\n        connectionHolder: this._connectionHolder,\n        onError: this._onError,\n        onComplete: this._onComplete,\n        onConnection: this._onConnection,\n        pendingResults: this._results\n      });\n\n      this._state = committed.state; // clean up\n\n      this._onClose();\n\n      return new Promise(function (resolve, reject) {\n        committed.result.subscribe({\n          onCompleted: function onCompleted() {\n            return resolve();\n          },\n          onError: function onError(error) {\n            return reject(error);\n          }\n        });\n      });\n    }\n    /**\r\n     * Rollbacks the transaction.\r\n     *\r\n     * After rolling back, the transaction can no longer be used.\r\n     *\r\n     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\r\n     * rollback.\r\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var rolledback = this._state.rollback({\n        connectionHolder: this._connectionHolder,\n        onError: this._onError,\n        onComplete: this._onComplete,\n        onConnection: this._onConnection,\n        pendingResults: this._results\n      });\n\n      this._state = rolledback.state; // clean up\n\n      this._onClose();\n\n      return new Promise(function (resolve, reject) {\n        rolledback.result.subscribe({\n          onCompleted: function onCompleted() {\n            return resolve();\n          },\n          onError: function onError(error) {\n            return reject(error);\n          }\n        });\n      });\n    }\n    /**\r\n     * Check if this transaction is active, which means commit and rollback did not happen.\r\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\r\n     */\n\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this._state === _states.ACTIVE;\n    }\n  }, {\n    key: \"_onErrorCallback\",\n    value: function _onErrorCallback(err) {\n      // error will be \"acknowledged\" by sending a RESET message\n      // database will then forget about this transaction and cleanup all corresponding resources\n      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\n      this._state = _states.FAILED;\n\n      this._onClose(); // release connection back to the pool\n\n\n      return this._connectionHolder.releaseConnection();\n    }\n  }, {\n    key: \"_onCompleteCallback\",\n    value: function _onCompleteCallback(meta) {\n      this._onBookmark(new _bookmark[\"default\"](meta.bookmark));\n    }\n  }]);\n  return Transaction;\n}();\n\nvar _states = {\n  // The transaction is running with no explicit success or failure marked\n  ACTIVE: {\n    commit: function commit(_ref2) {\n      var connectionHolder = _ref2.connectionHolder,\n          onError = _ref2.onError,\n          onComplete = _ref2.onComplete,\n          onConnection = _ref2.onConnection,\n          pendingResults = _ref2.pendingResults;\n      return {\n        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function rollback(_ref3) {\n      var connectionHolder = _ref3.connectionHolder,\n          onError = _ref3.onError,\n          onComplete = _ref3.onComplete,\n          onConnection = _ref3.onConnection,\n          pendingResults = _ref3.pendingResults;\n      return {\n        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(query, parameters, _ref4) {\n      var connectionHolder = _ref4.connectionHolder,\n          onError = _ref4.onError,\n          onComplete = _ref4.onComplete,\n          onConnection = _ref4.onConnection,\n          reactive = _ref4.reactive,\n          fetchSize = _ref4.fetchSize; // RUN in explicit transaction can't contain bookmarks and transaction configuration\n      // No need to include mode and database name as it shall be inclued in begin\n\n      var observerPromise = connectionHolder.getConnection().then(function (conn) {\n        onConnection();\n        return conn.protocol().run(query, parameters, {\n          bookmark: _bookmark[\"default\"].empty(),\n          txConfig: _txConfig[\"default\"].empty(),\n          beforeError: onError,\n          afterComplete: onComplete,\n          reactive: reactive,\n          fetchSize: fetchSize\n        });\n      })[\"catch\"](function (error) {\n        return new _streamObservers.FailedObserver({\n          error: error,\n          onError: onError\n        });\n      });\n      return newCompletedResult(observerPromise, query, parameters);\n    }\n  },\n  // An error has occurred, transaction can no longer be used and no more messages will\n  // be sent for this transaction.\n  FAILED: {\n    commit: function commit(_ref5) {\n      var connectionHolder = _ref5.connectionHolder,\n          onError = _ref5.onError,\n          onComplete = _ref5.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\n          onError: onError\n        }), 'COMMIT', {}),\n        state: _states.FAILED\n      };\n    },\n    rollback: function rollback(_ref6) {\n      var connectionHolder = _ref6.connectionHolder,\n          onError = _ref6.onError,\n          onComplete = _ref6.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.CompletedObserver(), 'ROLLBACK', {}),\n        state: _states.FAILED\n      };\n    },\n    run: function run(query, parameters, _ref7) {\n      var connectionHolder = _ref7.connectionHolder,\n          onError = _ref7.onError,\n          onComplete = _ref7.onComplete;\n      return newCompletedResult(new _streamObservers.FailedObserver({\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\n        onError: onError\n      }), query, parameters);\n    }\n  },\n  // This transaction has successfully committed\n  SUCCEEDED: {\n    commit: function commit(_ref8) {\n      var connectionHolder = _ref8.connectionHolder,\n          onError = _ref8.onError,\n          onComplete = _ref8.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot commit this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'COMMIT', {}),\n        state: _states.SUCCEEDED\n      };\n    },\n    rollback: function rollback(_ref9) {\n      var connectionHolder = _ref9.connectionHolder,\n          onError = _ref9.onError,\n          onComplete = _ref9.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been committed.'),\n          onError: onError\n        }), 'ROLLBACK', {}),\n        state: _states.SUCCEEDED\n      };\n    },\n    run: function run(query, parameters, _ref10) {\n      var connectionHolder = _ref10.connectionHolder,\n          onError = _ref10.onError,\n          onComplete = _ref10.onComplete;\n      return newCompletedResult(new _streamObservers.FailedObserver({\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been committed.'),\n        onError: onError\n      }), query, parameters);\n    }\n  },\n  // This transaction has been rolled back\n  ROLLED_BACK: {\n    commit: function commit(_ref11) {\n      var connectionHolder = _ref11.connectionHolder,\n          onError = _ref11.onError,\n          onComplete = _ref11.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot commit this transaction, because it has already been rolled back.'),\n          onError: onError\n        }), 'COMMIT', {}),\n        state: _states.ROLLED_BACK\n      };\n    },\n    rollback: function rollback(_ref12) {\n      var connectionHolder = _ref12.connectionHolder,\n          onError = _ref12.onError,\n          onComplete = _ref12.onComplete;\n      return {\n        result: newCompletedResult(new _streamObservers.FailedObserver({\n          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been rolled back.')\n        }), 'ROLLBACK', {}),\n        state: _states.ROLLED_BACK\n      };\n    },\n    run: function run(query, parameters, _ref13) {\n      var connectionHolder = _ref13.connectionHolder,\n          onError = _ref13.onError,\n          onComplete = _ref13.onComplete;\n      return newCompletedResult(new _streamObservers.FailedObserver({\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\n        onError: onError\n      }), query, parameters);\n    }\n  }\n  /**\r\n   *\r\n   * @param {boolean} commit\r\n   * @param {ConnectionHolder} connectionHolder\r\n   * @param {function(err:Error): any} onError\r\n   * @param {function(metadata:object): any} onComplete\r\n   * @param {function() : any} onConnection\r\n   * @param {list<Result>>}pendingResults all run results in this transaction\r\n   */\n\n};\n\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\n  var observerPromise = connectionHolder.getConnection().then(function (connection) {\n    onConnection();\n    pendingResults.forEach(function (r) {\n      return r._cancel();\n    });\n    return Promise.all(pendingResults).then(function (results) {\n      if (commit) {\n        return connection.protocol().commitTransaction({\n          beforeError: onError,\n          afterComplete: onComplete\n        });\n      } else {\n        return connection.protocol().rollbackTransaction({\n          beforeError: onError,\n          afterComplete: onComplete\n        });\n      }\n    });\n  })[\"catch\"](function (error) {\n    return new _streamObservers.FailedObserver({\n      error: error,\n      onError: onError\n    });\n  }); // for commit & rollback we need result that uses real connection holder and notifies it when\n  // connection is not needed and can be safely released to the pool\n\n  return new _result[\"default\"](observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\n}\n/**\r\n * Creates a {@link Result} with empty connection holder.\r\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\r\n * need to influence real connection holder to release connections.\r\n * @param {ResultStreamObserver} observer - an observer for the created result.\r\n * @param {string} query - the cypher query that produced the result.\r\n * @param {Object} parameters - the parameters for cypher query that produced the result.\r\n * @return {Result} new result.\r\n * @private\r\n */\n\n\nfunction newCompletedResult(observerPromise, query, parameters) {\n  return new _result[\"default\"](Promise.resolve(observerPromise), query, parameters, _connectionHolder.EMPTY_CONNECTION_HOLDER);\n}\n\nvar _default = Transaction;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:/Users/a1ole/Documents/GitHub/neo4jreact/node_modules/neo4j-driver/lib/transaction.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","_classCallCheck2","_createClass2","_result","_util","_connectionHolder","_bookmark","_txConfig","_streamObservers","_error","Transaction","_ref","connectionHolder","onClose","onBookmark","onConnection","reactive","fetchSize","_reactive","_state","_states","ACTIVE","_onClose","_onBookmark","_onConnection","_onError","_onErrorCallback","bind","_onComplete","_onCompleteCallback","_fetchSize","_results","key","_begin","bookmark","txConfig","_this","getConnection","then","conn","protocol","beginTransaction","mode","database","beforeError","afterComplete","error","run","query","parameters","_validateQueryAndPara","validateQueryAndParameters","validatedQuery","params","result","onError","onComplete","push","commit","committed","pendingResults","state","Promise","resolve","reject","subscribe","onCompleted","rollback","rolledback","isOpen","err","FAILED","releaseConnection","meta","_ref2","finishTransaction","SUCCEEDED","_ref3","ROLLED_BACK","_ref4","observerPromise","empty","FailedObserver","newCompletedResult","_ref5","newError","_ref6","CompletedObserver","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","connection","forEach","r","_cancel","all","results","commitTransaction","rollbackTransaction","EMPTY_CONNECTION_HOLDER","_default"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = void 0;\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\r\n\r\nvar _result = _interopRequireDefault(require(\"./result\"));\r\n\r\nvar _util = require(\"./internal/util\");\r\n\r\nvar _connectionHolder = _interopRequireWildcard(require(\"./internal/connection-holder\"));\r\n\r\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\r\n\r\nvar _txConfig = _interopRequireDefault(require(\"./internal/tx-config\"));\r\n\r\nvar _streamObservers = require(\"./internal/stream-observers\");\r\n\r\nvar _error = require(\"./error\");\r\n\r\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Represents a transaction in the Neo4j database.\r\n *\r\n * @access public\r\n */\r\nvar Transaction =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * @constructor\r\n   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.\r\n   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.\r\n   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.\r\n   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton\r\n   * is not yet released.\r\n   * @param {boolean} reactive whether this transaction generates reactive streams\r\n   * @param {number} fetchSize - the record fetch size in each pulling batch.\r\n   */\r\n  function Transaction(_ref) {\r\n    var connectionHolder = _ref.connectionHolder,\r\n        onClose = _ref.onClose,\r\n        onBookmark = _ref.onBookmark,\r\n        onConnection = _ref.onConnection,\r\n        reactive = _ref.reactive,\r\n        fetchSize = _ref.fetchSize;\r\n    (0, _classCallCheck2[\"default\"])(this, Transaction);\r\n    this._connectionHolder = connectionHolder;\r\n    this._reactive = reactive;\r\n    this._state = _states.ACTIVE;\r\n    this._onClose = onClose;\r\n    this._onBookmark = onBookmark;\r\n    this._onConnection = onConnection;\r\n    this._onError = this._onErrorCallback.bind(this);\r\n    this._onComplete = this._onCompleteCallback.bind(this);\r\n    this._fetchSize = fetchSize;\r\n    this._results = [];\r\n  }\r\n\r\n  (0, _createClass2[\"default\"])(Transaction, [{\r\n    key: \"_begin\",\r\n    value: function _begin(bookmark, txConfig) {\r\n      var _this = this;\r\n\r\n      this._connectionHolder.getConnection().then(function (conn) {\r\n        _this._onConnection();\r\n\r\n        return conn.protocol().beginTransaction({\r\n          bookmark: bookmark,\r\n          txConfig: txConfig,\r\n          mode: _this._connectionHolder.mode(),\r\n          database: _this._connectionHolder.database(),\r\n          beforeError: _this._onError,\r\n          afterComplete: _this._onComplete\r\n        });\r\n      })[\"catch\"](function (error) {\r\n        return _this._onError(error);\r\n      });\r\n    }\r\n    /**\r\n     * Run Cypher query\r\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\r\n     * or with the query and parameters as separate arguments.\r\n     * @param {mixed} query - Cypher query to execute\r\n     * @param {Object} parameters - Map with parameters to use in query\r\n     * @return {Result} New Result\r\n     */\r\n\r\n  }, {\r\n    key: \"run\",\r\n    value: function run(query, parameters) {\r\n      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),\r\n          validatedQuery = _validateQueryAndPara.validatedQuery,\r\n          params = _validateQueryAndPara.params;\r\n\r\n      var result = this._state.run(validatedQuery, params, {\r\n        connectionHolder: this._connectionHolder,\r\n        onError: this._onError,\r\n        onComplete: this._onComplete,\r\n        onConnection: this._onConnection,\r\n        reactive: this._reactive,\r\n        fetchSize: this._fetchSize\r\n      });\r\n\r\n      this._results.push(result);\r\n\r\n      return result;\r\n    }\r\n    /**\r\n     * Commits the transaction and returns the result.\r\n     *\r\n     * After committing the transaction can no longer be used.\r\n     *\r\n     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.\r\n     */\r\n\r\n  }, {\r\n    key: \"commit\",\r\n    value: function commit() {\r\n      var committed = this._state.commit({\r\n        connectionHolder: this._connectionHolder,\r\n        onError: this._onError,\r\n        onComplete: this._onComplete,\r\n        onConnection: this._onConnection,\r\n        pendingResults: this._results\r\n      });\r\n\r\n      this._state = committed.state; // clean up\r\n\r\n      this._onClose();\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        committed.result.subscribe({\r\n          onCompleted: function onCompleted() {\r\n            return resolve();\r\n          },\r\n          onError: function onError(error) {\r\n            return reject(error);\r\n          }\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Rollbacks the transaction.\r\n     *\r\n     * After rolling back, the transaction can no longer be used.\r\n     *\r\n     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during\r\n     * rollback.\r\n     */\r\n\r\n  }, {\r\n    key: \"rollback\",\r\n    value: function rollback() {\r\n      var rolledback = this._state.rollback({\r\n        connectionHolder: this._connectionHolder,\r\n        onError: this._onError,\r\n        onComplete: this._onComplete,\r\n        onConnection: this._onConnection,\r\n        pendingResults: this._results\r\n      });\r\n\r\n      this._state = rolledback.state; // clean up\r\n\r\n      this._onClose();\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        rolledback.result.subscribe({\r\n          onCompleted: function onCompleted() {\r\n            return resolve();\r\n          },\r\n          onError: function onError(error) {\r\n            return reject(error);\r\n          }\r\n        });\r\n      });\r\n    }\r\n    /**\r\n     * Check if this transaction is active, which means commit and rollback did not happen.\r\n     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.\r\n     */\r\n\r\n  }, {\r\n    key: \"isOpen\",\r\n    value: function isOpen() {\r\n      return this._state === _states.ACTIVE;\r\n    }\r\n  }, {\r\n    key: \"_onErrorCallback\",\r\n    value: function _onErrorCallback(err) {\r\n      // error will be \"acknowledged\" by sending a RESET message\r\n      // database will then forget about this transaction and cleanup all corresponding resources\r\n      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it\r\n      this._state = _states.FAILED;\r\n\r\n      this._onClose(); // release connection back to the pool\r\n\r\n\r\n      return this._connectionHolder.releaseConnection();\r\n    }\r\n  }, {\r\n    key: \"_onCompleteCallback\",\r\n    value: function _onCompleteCallback(meta) {\r\n      this._onBookmark(new _bookmark[\"default\"](meta.bookmark));\r\n    }\r\n  }]);\r\n  return Transaction;\r\n}();\r\n\r\nvar _states = {\r\n  // The transaction is running with no explicit success or failure marked\r\n  ACTIVE: {\r\n    commit: function commit(_ref2) {\r\n      var connectionHolder = _ref2.connectionHolder,\r\n          onError = _ref2.onError,\r\n          onComplete = _ref2.onComplete,\r\n          onConnection = _ref2.onConnection,\r\n          pendingResults = _ref2.pendingResults;\r\n      return {\r\n        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),\r\n        state: _states.SUCCEEDED\r\n      };\r\n    },\r\n    rollback: function rollback(_ref3) {\r\n      var connectionHolder = _ref3.connectionHolder,\r\n          onError = _ref3.onError,\r\n          onComplete = _ref3.onComplete,\r\n          onConnection = _ref3.onConnection,\r\n          pendingResults = _ref3.pendingResults;\r\n      return {\r\n        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),\r\n        state: _states.ROLLED_BACK\r\n      };\r\n    },\r\n    run: function run(query, parameters, _ref4) {\r\n      var connectionHolder = _ref4.connectionHolder,\r\n          onError = _ref4.onError,\r\n          onComplete = _ref4.onComplete,\r\n          onConnection = _ref4.onConnection,\r\n          reactive = _ref4.reactive,\r\n          fetchSize = _ref4.fetchSize;\r\n      // RUN in explicit transaction can't contain bookmarks and transaction configuration\r\n      // No need to include mode and database name as it shall be inclued in begin\r\n      var observerPromise = connectionHolder.getConnection().then(function (conn) {\r\n        onConnection();\r\n        return conn.protocol().run(query, parameters, {\r\n          bookmark: _bookmark[\"default\"].empty(),\r\n          txConfig: _txConfig[\"default\"].empty(),\r\n          beforeError: onError,\r\n          afterComplete: onComplete,\r\n          reactive: reactive,\r\n          fetchSize: fetchSize\r\n        });\r\n      })[\"catch\"](function (error) {\r\n        return new _streamObservers.FailedObserver({\r\n          error: error,\r\n          onError: onError\r\n        });\r\n      });\r\n      return newCompletedResult(observerPromise, query, parameters);\r\n    }\r\n  },\r\n  // An error has occurred, transaction can no longer be used and no more messages will\r\n  // be sent for this transaction.\r\n  FAILED: {\r\n    commit: function commit(_ref5) {\r\n      var connectionHolder = _ref5.connectionHolder,\r\n          onError = _ref5.onError,\r\n          onComplete = _ref5.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.FailedObserver({\r\n          error: (0, _error.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),\r\n          onError: onError\r\n        }), 'COMMIT', {}),\r\n        state: _states.FAILED\r\n      };\r\n    },\r\n    rollback: function rollback(_ref6) {\r\n      var connectionHolder = _ref6.connectionHolder,\r\n          onError = _ref6.onError,\r\n          onComplete = _ref6.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.CompletedObserver(), 'ROLLBACK', {}),\r\n        state: _states.FAILED\r\n      };\r\n    },\r\n    run: function run(query, parameters, _ref7) {\r\n      var connectionHolder = _ref7.connectionHolder,\r\n          onError = _ref7.onError,\r\n          onComplete = _ref7.onComplete;\r\n      return newCompletedResult(new _streamObservers.FailedObserver({\r\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),\r\n        onError: onError\r\n      }), query, parameters);\r\n    }\r\n  },\r\n  // This transaction has successfully committed\r\n  SUCCEEDED: {\r\n    commit: function commit(_ref8) {\r\n      var connectionHolder = _ref8.connectionHolder,\r\n          onError = _ref8.onError,\r\n          onComplete = _ref8.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.FailedObserver({\r\n          error: (0, _error.newError)('Cannot commit this transaction, because it has already been committed.'),\r\n          onError: onError\r\n        }), 'COMMIT', {}),\r\n        state: _states.SUCCEEDED\r\n      };\r\n    },\r\n    rollback: function rollback(_ref9) {\r\n      var connectionHolder = _ref9.connectionHolder,\r\n          onError = _ref9.onError,\r\n          onComplete = _ref9.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.FailedObserver({\r\n          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been committed.'),\r\n          onError: onError\r\n        }), 'ROLLBACK', {}),\r\n        state: _states.SUCCEEDED\r\n      };\r\n    },\r\n    run: function run(query, parameters, _ref10) {\r\n      var connectionHolder = _ref10.connectionHolder,\r\n          onError = _ref10.onError,\r\n          onComplete = _ref10.onComplete;\r\n      return newCompletedResult(new _streamObservers.FailedObserver({\r\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been committed.'),\r\n        onError: onError\r\n      }), query, parameters);\r\n    }\r\n  },\r\n  // This transaction has been rolled back\r\n  ROLLED_BACK: {\r\n    commit: function commit(_ref11) {\r\n      var connectionHolder = _ref11.connectionHolder,\r\n          onError = _ref11.onError,\r\n          onComplete = _ref11.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.FailedObserver({\r\n          error: (0, _error.newError)('Cannot commit this transaction, because it has already been rolled back.'),\r\n          onError: onError\r\n        }), 'COMMIT', {}),\r\n        state: _states.ROLLED_BACK\r\n      };\r\n    },\r\n    rollback: function rollback(_ref12) {\r\n      var connectionHolder = _ref12.connectionHolder,\r\n          onError = _ref12.onError,\r\n          onComplete = _ref12.onComplete;\r\n      return {\r\n        result: newCompletedResult(new _streamObservers.FailedObserver({\r\n          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been rolled back.')\r\n        }), 'ROLLBACK', {}),\r\n        state: _states.ROLLED_BACK\r\n      };\r\n    },\r\n    run: function run(query, parameters, _ref13) {\r\n      var connectionHolder = _ref13.connectionHolder,\r\n          onError = _ref13.onError,\r\n          onComplete = _ref13.onComplete;\r\n      return newCompletedResult(new _streamObservers.FailedObserver({\r\n        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been rolled back.'),\r\n        onError: onError\r\n      }), query, parameters);\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * @param {boolean} commit\r\n   * @param {ConnectionHolder} connectionHolder\r\n   * @param {function(err:Error): any} onError\r\n   * @param {function(metadata:object): any} onComplete\r\n   * @param {function() : any} onConnection\r\n   * @param {list<Result>>}pendingResults all run results in this transaction\r\n   */\r\n\r\n};\r\n\r\nfunction finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {\r\n  var observerPromise = connectionHolder.getConnection().then(function (connection) {\r\n    onConnection();\r\n    pendingResults.forEach(function (r) {\r\n      return r._cancel();\r\n    });\r\n    return Promise.all(pendingResults).then(function (results) {\r\n      if (commit) {\r\n        return connection.protocol().commitTransaction({\r\n          beforeError: onError,\r\n          afterComplete: onComplete\r\n        });\r\n      } else {\r\n        return connection.protocol().rollbackTransaction({\r\n          beforeError: onError,\r\n          afterComplete: onComplete\r\n        });\r\n      }\r\n    });\r\n  })[\"catch\"](function (error) {\r\n    return new _streamObservers.FailedObserver({\r\n      error: error,\r\n      onError: onError\r\n    });\r\n  }); // for commit & rollback we need result that uses real connection holder and notifies it when\r\n  // connection is not needed and can be safely released to the pool\r\n\r\n  return new _result[\"default\"](observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);\r\n}\r\n/**\r\n * Creates a {@link Result} with empty connection holder.\r\n * For cases when result represents an intermediate or failed action, does not require any metadata and does not\r\n * need to influence real connection holder to release connections.\r\n * @param {ResultStreamObserver} observer - an observer for the created result.\r\n * @param {string} query - the cypher query that produced the result.\r\n * @param {Object} parameters - the parameters for cypher query that produced the result.\r\n * @return {Result} new result.\r\n * @private\r\n */\r\n\r\n\r\nfunction newCompletedResult(observerPromise, query, parameters) {\r\n  return new _result[\"default\"](Promise.resolve(observerPromise), query, parameters, _connectionHolder.EMPTY_CONNECTION_HOLDER);\r\n}\r\n\r\nvar _default = Transaction;\r\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}