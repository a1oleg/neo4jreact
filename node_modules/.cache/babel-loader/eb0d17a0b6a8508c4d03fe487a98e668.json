{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNode = isNode;\nexports.isRelationship = isRelationship;\nexports.isUnboundRelationship = isUnboundRelationship;\nexports.isPath = isPath;\nexports.isPathSegment = isPathSegment;\nexports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\n  value: true,\n  enumerable: false,\n  configurable: false,\n  writable: false\n};\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\n\nfunction hasIdentifierProperty(obj, property) {\n  return (obj && obj[property]) === true;\n}\n/**\r\n * Class for Node Type.\r\n */\n\n\nvar Node = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {Array<string>} labels - Array for all labels\r\n   * @param {Object} properties - Map with node properties\r\n   */\n  function Node(identity, labels, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Node);\n    /**\r\n     * Identity of the node.\r\n     * @type {Integer}\r\n     */\n\n    this.identity = identity;\n    /**\r\n     * Labels of the node.\r\n     * @type {string[]}\r\n     */\n\n    this.labels = labels;\n    /**\r\n     * Properties of the node.\r\n     * @type {Object}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  (0, _createClass2[\"default\"])(Node, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.identity;\n\n      for (var i = 0; i < this.labels.length; i++) {\n        s += ':' + this.labels[i];\n      }\n\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var _i = 0; _i < keys.length; _i++) {\n          if (_i > 0) s += ',';\n          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ')';\n      return s;\n    }\n  }]);\n  return Node;\n}();\n\nexports.Node = Node;\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Node} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\r\n */\n\nfunction isNode(obj) {\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\n}\n/**\r\n * Class for Relationship Type.\r\n */\n\n\nvar Relationship = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {Integer} start - Identity of start Node\r\n   * @param {Integer} end - Identity of end Node\r\n   * @param {string} type - Relationship type\r\n   * @param {Object} properties - Map with relationship properties\r\n   */\n  function Relationship(identity, start, end, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, Relationship);\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer}\r\n     */\n\n    this.identity = identity;\n    /**\r\n     * Identity of the start node.\r\n     * @type {Integer}\r\n     */\n\n    this.start = start;\n    /**\r\n     * Identity of the end node.\r\n     * @type {Integer}\r\n     */\n\n    this.end = end;\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\n\n    this.type = type;\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Object}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  (0, _createClass2[\"default\"])(Relationship, [{\n    key: \"toString\",\n    value: function toString() {\n      var s = '(' + this.start + ')-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->(' + this.end + ')';\n      return s;\n    }\n  }]);\n  return Relationship;\n}();\n\nexports.Relationship = Relationship;\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Relationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\r\n */\n\nfunction isRelationship(obj) {\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\r\n * Class for UnboundRelationship Type.\r\n * @access private\r\n */\n\n\nvar UnboundRelationship = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {string} type - Relationship type\r\n   * @param {Object} properties - Map with relationship properties\r\n   */\n  function UnboundRelationship(identity, type, properties) {\n    (0, _classCallCheck2[\"default\"])(this, UnboundRelationship);\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer}\r\n     */\n\n    this.identity = identity;\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\n\n    this.type = type;\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Object}\r\n     */\n\n    this.properties = properties;\n  }\n  /**\r\n   * Bind relationship\r\n   *\r\n   * @protected\r\n   * @param {Integer} start - Identity of start node\r\n   * @param {Integer} end - Identity of end node\r\n   * @return {Relationship} - Created relationship\r\n   */\n\n\n  (0, _createClass2[\"default\"])(UnboundRelationship, [{\n    key: \"bind\",\n    value: function bind(start, end) {\n      return new Relationship(this.identity, start, end, this.type, this.properties);\n    }\n    /**\r\n     * @ignore\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var s = '-[:' + this.type;\n      var keys = Object.keys(this.properties);\n\n      if (keys.length > 0) {\n        s += ' {';\n\n        for (var i = 0; i < keys.length; i++) {\n          if (i > 0) s += ',';\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\n        }\n\n        s += '}';\n      }\n\n      s += ']->';\n      return s;\n    }\n  }]);\n  return UnboundRelationship;\n}();\n\nexports.UnboundRelationship = UnboundRelationship;\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link UnboundRelationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\r\n */\n\nfunction isUnboundRelationship(obj) {\n  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);\n}\n/**\r\n * Class for PathSegment Type.\r\n */\n\n\nvar PathSegment =\n/**\r\n * @constructor\r\n * @protected\r\n * @param {Node} start - start node\r\n * @param {Relationship} rel - relationship that connects start and end node\r\n * @param {Node} end - end node\r\n */\nfunction PathSegment(start, rel, end) {\n  (0, _classCallCheck2[\"default\"])(this, PathSegment);\n  /**\r\n   * Start node.\r\n   * @type {Node}\r\n   */\n\n  this.start = start;\n  /**\r\n   * Relationship.\r\n   * @type {Relationship}\r\n   */\n\n  this.relationship = rel;\n  /**\r\n   * End node.\r\n   * @type {Node}\r\n   */\n\n  this.end = end;\n};\n\nexports.PathSegment = PathSegment;\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link PathSegment} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\r\n */\n\nfunction isPathSegment(obj) {\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\n}\n/**\r\n * Class for Path Type.\r\n */\n\n\nvar Path =\n/**\r\n * @constructor\r\n * @protected\r\n * @param {Node} start  - start node\r\n * @param {Node} end - end node\r\n * @param {Array<PathSegment>} segments - Array of Segments\r\n */\nfunction Path(start, end, segments) {\n  (0, _classCallCheck2[\"default\"])(this, Path);\n  /**\r\n   * Start node.\r\n   * @type {Node}\r\n   */\n\n  this.start = start;\n  /**\r\n   * End node.\r\n   * @type {Node}\r\n   */\n\n  this.end = end;\n  /**\r\n   * Segments.\r\n   * @type {Array<PathSegment>}\r\n   */\n\n  this.segments = segments;\n  /**\r\n   * Length of the segments.\r\n   * @type {Number}\r\n   */\n\n  this.length = segments.length;\n};\n\nexports.Path = Path;\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\n/**\r\n * Test if given object is an instance of {@link Path} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\r\n */\n\nfunction isPath(obj) {\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\n}","map":{"version":3,"sources":["C:/Users/a1ole/Documents/GitHub/neo4jreact/node_modules/neo4j-driver/lib/graph-types.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","isNode","isRelationship","isUnboundRelationship","isPath","isPathSegment","PathSegment","Path","UnboundRelationship","Relationship","Node","_classCallCheck2","_createClass2","IDENTIFIER_PROPERTY_ATTRIBUTES","enumerable","configurable","writable","NODE_IDENTIFIER_PROPERTY","RELATIONSHIP_IDENTIFIER_PROPERTY","UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY","PATH_IDENTIFIER_PROPERTY","PATH_SEGMENT_IDENTIFIER_PROPERTY","hasIdentifierProperty","obj","property","identity","labels","properties","key","toString","s","i","length","keys","_i","JSON","stringify","prototype","start","end","type","bind","UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY","rel","relationship","segments"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.isNode = isNode;\r\nexports.isRelationship = isRelationship;\r\nexports.isUnboundRelationship = isUnboundRelationship;\r\nexports.isPath = isPath;\r\nexports.isPathSegment = isPathSegment;\r\nexports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\r\n\r\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar IDENTIFIER_PROPERTY_ATTRIBUTES = {\r\n  value: true,\r\n  enumerable: false,\r\n  configurable: false,\r\n  writable: false\r\n};\r\nvar NODE_IDENTIFIER_PROPERTY = '__isNode__';\r\nvar RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';\r\nvar UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';\r\nvar PATH_IDENTIFIER_PROPERTY = '__isPath__';\r\nvar PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';\r\n\r\nfunction hasIdentifierProperty(obj, property) {\r\n  return (obj && obj[property]) === true;\r\n}\r\n/**\r\n * Class for Node Type.\r\n */\r\n\r\n\r\nvar Node =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {Array<string>} labels - Array for all labels\r\n   * @param {Object} properties - Map with node properties\r\n   */\r\n  function Node(identity, labels, properties) {\r\n    (0, _classCallCheck2[\"default\"])(this, Node);\r\n\r\n    /**\r\n     * Identity of the node.\r\n     * @type {Integer}\r\n     */\r\n    this.identity = identity;\r\n    /**\r\n     * Labels of the node.\r\n     * @type {string[]}\r\n     */\r\n\r\n    this.labels = labels;\r\n    /**\r\n     * Properties of the node.\r\n     * @type {Object}\r\n     */\r\n\r\n    this.properties = properties;\r\n  }\r\n  /**\r\n   * @ignore\r\n   */\r\n\r\n\r\n  (0, _createClass2[\"default\"])(Node, [{\r\n    key: \"toString\",\r\n    value: function toString() {\r\n      var s = '(' + this.identity;\r\n\r\n      for (var i = 0; i < this.labels.length; i++) {\r\n        s += ':' + this.labels[i];\r\n      }\r\n\r\n      var keys = Object.keys(this.properties);\r\n\r\n      if (keys.length > 0) {\r\n        s += ' {';\r\n\r\n        for (var _i = 0; _i < keys.length; _i++) {\r\n          if (_i > 0) s += ',';\r\n          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);\r\n        }\r\n\r\n        s += '}';\r\n      }\r\n\r\n      s += ')';\r\n      return s;\r\n    }\r\n  }]);\r\n  return Node;\r\n}();\r\n\r\nexports.Node = Node;\r\nObject.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Node} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.\r\n */\r\n\r\nfunction isNode(obj) {\r\n  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);\r\n}\r\n/**\r\n * Class for Relationship Type.\r\n */\r\n\r\n\r\nvar Relationship =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {Integer} start - Identity of start Node\r\n   * @param {Integer} end - Identity of end Node\r\n   * @param {string} type - Relationship type\r\n   * @param {Object} properties - Map with relationship properties\r\n   */\r\n  function Relationship(identity, start, end, type, properties) {\r\n    (0, _classCallCheck2[\"default\"])(this, Relationship);\r\n\r\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer}\r\n     */\r\n    this.identity = identity;\r\n    /**\r\n     * Identity of the start node.\r\n     * @type {Integer}\r\n     */\r\n\r\n    this.start = start;\r\n    /**\r\n     * Identity of the end node.\r\n     * @type {Integer}\r\n     */\r\n\r\n    this.end = end;\r\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\r\n\r\n    this.type = type;\r\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Object}\r\n     */\r\n\r\n    this.properties = properties;\r\n  }\r\n  /**\r\n   * @ignore\r\n   */\r\n\r\n\r\n  (0, _createClass2[\"default\"])(Relationship, [{\r\n    key: \"toString\",\r\n    value: function toString() {\r\n      var s = '(' + this.start + ')-[:' + this.type;\r\n      var keys = Object.keys(this.properties);\r\n\r\n      if (keys.length > 0) {\r\n        s += ' {';\r\n\r\n        for (var i = 0; i < keys.length; i++) {\r\n          if (i > 0) s += ',';\r\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\r\n        }\r\n\r\n        s += '}';\r\n      }\r\n\r\n      s += ']->(' + this.end + ')';\r\n      return s;\r\n    }\r\n  }]);\r\n  return Relationship;\r\n}();\r\n\r\nexports.Relationship = Relationship;\r\nObject.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Relationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.\r\n */\r\n\r\nfunction isRelationship(obj) {\r\n  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);\r\n}\r\n/**\r\n * Class for UnboundRelationship Type.\r\n * @access private\r\n */\r\n\r\n\r\nvar UnboundRelationship =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * @constructor\r\n   * @protected\r\n   * @param {Integer} identity - Unique identity\r\n   * @param {string} type - Relationship type\r\n   * @param {Object} properties - Map with relationship properties\r\n   */\r\n  function UnboundRelationship(identity, type, properties) {\r\n    (0, _classCallCheck2[\"default\"])(this, UnboundRelationship);\r\n\r\n    /**\r\n     * Identity of the relationship.\r\n     * @type {Integer}\r\n     */\r\n    this.identity = identity;\r\n    /**\r\n     * Type of the relationship.\r\n     * @type {string}\r\n     */\r\n\r\n    this.type = type;\r\n    /**\r\n     * Properties of the relationship.\r\n     * @type {Object}\r\n     */\r\n\r\n    this.properties = properties;\r\n  }\r\n  /**\r\n   * Bind relationship\r\n   *\r\n   * @protected\r\n   * @param {Integer} start - Identity of start node\r\n   * @param {Integer} end - Identity of end node\r\n   * @return {Relationship} - Created relationship\r\n   */\r\n\r\n\r\n  (0, _createClass2[\"default\"])(UnboundRelationship, [{\r\n    key: \"bind\",\r\n    value: function bind(start, end) {\r\n      return new Relationship(this.identity, start, end, this.type, this.properties);\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n\r\n  }, {\r\n    key: \"toString\",\r\n    value: function toString() {\r\n      var s = '-[:' + this.type;\r\n      var keys = Object.keys(this.properties);\r\n\r\n      if (keys.length > 0) {\r\n        s += ' {';\r\n\r\n        for (var i = 0; i < keys.length; i++) {\r\n          if (i > 0) s += ',';\r\n          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);\r\n        }\r\n\r\n        s += '}';\r\n      }\r\n\r\n      s += ']->';\r\n      return s;\r\n    }\r\n  }]);\r\n  return UnboundRelationship;\r\n}();\r\n\r\nexports.UnboundRelationship = UnboundRelationship;\r\nObject.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link UnboundRelationship} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.\r\n */\r\n\r\nfunction isUnboundRelationship(obj) {\r\n  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);\r\n}\r\n/**\r\n * Class for PathSegment Type.\r\n */\r\n\r\n\r\nvar PathSegment =\r\n/**\r\n * @constructor\r\n * @protected\r\n * @param {Node} start - start node\r\n * @param {Relationship} rel - relationship that connects start and end node\r\n * @param {Node} end - end node\r\n */\r\nfunction PathSegment(start, rel, end) {\r\n  (0, _classCallCheck2[\"default\"])(this, PathSegment);\r\n\r\n  /**\r\n   * Start node.\r\n   * @type {Node}\r\n   */\r\n  this.start = start;\r\n  /**\r\n   * Relationship.\r\n   * @type {Relationship}\r\n   */\r\n\r\n  this.relationship = rel;\r\n  /**\r\n   * End node.\r\n   * @type {Node}\r\n   */\r\n\r\n  this.end = end;\r\n};\r\n\r\nexports.PathSegment = PathSegment;\r\nObject.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link PathSegment} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.\r\n */\r\n\r\nfunction isPathSegment(obj) {\r\n  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);\r\n}\r\n/**\r\n * Class for Path Type.\r\n */\r\n\r\n\r\nvar Path =\r\n/**\r\n * @constructor\r\n * @protected\r\n * @param {Node} start  - start node\r\n * @param {Node} end - end node\r\n * @param {Array<PathSegment>} segments - Array of Segments\r\n */\r\nfunction Path(start, end, segments) {\r\n  (0, _classCallCheck2[\"default\"])(this, Path);\r\n\r\n  /**\r\n   * Start node.\r\n   * @type {Node}\r\n   */\r\n  this.start = start;\r\n  /**\r\n   * End node.\r\n   * @type {Node}\r\n   */\r\n\r\n  this.end = end;\r\n  /**\r\n   * Segments.\r\n   * @type {Array<PathSegment>}\r\n   */\r\n\r\n  this.segments = segments;\r\n  /**\r\n   * Length of the segments.\r\n   * @type {Number}\r\n   */\r\n\r\n  this.length = segments.length;\r\n};\r\n\r\nexports.Path = Path;\r\nObject.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);\r\n/**\r\n * Test if given object is an instance of {@link Path} class.\r\n * @param {Object} obj the object to test.\r\n * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.\r\n */\r\n\r\nfunction isPath(obj) {\r\n  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);\r\n}"]},"metadata":{},"sourceType":"script"}