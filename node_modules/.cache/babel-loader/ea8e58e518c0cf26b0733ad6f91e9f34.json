{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"../error\");\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\n\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\n\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\n\nvar TransactionExecutor = /*#__PURE__*/function () {\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n    (0, _classCallCheck2[\"default\"])(this, TransactionExecutor);\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._inFlightTimeoutIds = [];\n\n    this._verifyAfterConstruction();\n  }\n\n  (0, _createClass2[\"default\"])(TransactionExecutor, [{\n    key: \"execute\",\n    value: function execute(transactionCreator, transactionWork) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n      })[\"catch\"](function (error) {\n        var retryStartTimeMs = Date.now();\n        var retryDelayMs = _this._initialRetryDelayMs;\n        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      // cancel all existing timeouts to prevent further retries\n      this._inFlightTimeoutIds.forEach(function (timeoutId) {\n        return clearTimeout(timeoutId);\n      });\n\n      this._inFlightTimeoutIds = [];\n    }\n  }, {\n    key: \"_retryTransactionPromise\",\n    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n      var _this2 = this;\n\n      var elapsedTimeMs = Date.now() - retryStartTime;\n\n      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {\n        return Promise.reject(error);\n      }\n\n      return new Promise(function (resolve, reject) {\n        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);\n\n        var timeoutId = setTimeout(function () {\n          // filter out this timeoutId when time has come and function is being executed\n          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {\n            return id !== timeoutId;\n          });\n\n          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts\n\n        _this2._inFlightTimeoutIds.push(timeoutId);\n      })[\"catch\"](function (error) {\n        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;\n        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n      });\n    }\n  }, {\n    key: \"_executeTransactionInsidePromise\",\n    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {\n      var _this3 = this;\n\n      var tx;\n\n      try {\n        tx = transactionCreator();\n      } catch (error) {\n        // failed to create a transaction\n        reject(error);\n        return;\n      }\n\n      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n\n      resultPromise.then(function (result) {\n        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);\n      })[\"catch\"](function (error) {\n        return _this3._handleTransactionWorkFailure(error, tx, reject);\n      });\n    }\n  }, {\n    key: \"_safeExecuteTransactionWork\",\n    value: function _safeExecuteTransactionWork(tx, transactionWork) {\n      try {\n        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an\n        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n        // validation step without type checks\n\n        return Promise.resolve(result);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n  }, {\n    key: \"_handleTransactionWorkSuccess\",\n    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {\n      if (tx.isOpen()) {\n        // transaction work returned resolved promise and transaction has not been committed/rolled back\n        // try to commit the transaction\n        tx.commit().then(function () {\n          // transaction was committed, return result to the user\n          resolve(result);\n        })[\"catch\"](function (error) {\n          // transaction failed to commit, propagate the failure\n          reject(error);\n        });\n      } else {\n        // transaction work returned resolved promise and transaction is already committed/rolled back\n        // return the result returned by given transaction work\n        resolve(result);\n      }\n    }\n  }, {\n    key: \"_handleTransactionWorkFailure\",\n    value: function _handleTransactionWorkFailure(error, tx, reject) {\n      if (tx.isOpen()) {\n        // transaction work failed and the transaction is still open, roll it back and propagate the failure\n        tx.rollback()[\"catch\"](function (ignore) {// ignore the rollback error\n        }).then(function () {\n          return reject(error);\n        }); // propagate the original error we got from the transaction work\n      } else {\n        // transaction is already rolled back, propagate the error\n        reject(error);\n      }\n    }\n  }, {\n    key: \"_computeDelayWithJitter\",\n    value: function _computeDelayWithJitter(delayMs) {\n      var jitter = delayMs * this._jitterFactor;\n      var min = delayMs - jitter;\n      var max = delayMs + jitter;\n      return Math.random() * (max - min) + min;\n    }\n  }, {\n    key: \"_verifyAfterConstruction\",\n    value: function _verifyAfterConstruction() {\n      if (this._maxRetryTimeMs < 0) {\n        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n      }\n\n      if (this._initialRetryDelayMs < 0) {\n        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n      }\n\n      if (this._multiplier < 1.0) {\n        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n      }\n\n      if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n      }\n    }\n  }], [{\n    key: \"_canRetryOn\",\n    value: function _canRetryOn(error) {\n      return error && error instanceof _error.Neo4jError && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));\n    }\n  }, {\n    key: \"_isTransientError\",\n    value: function _isTransientError(error) {\n      // Retries should not happen when transaction was explicitly terminated by the user.\n      // Termination of transaction might result in two different error codes depending on where it was\n      // terminated. These are really client errors but classification on the server is not entirely correct and\n      // they are classified as transient.\n      var code = error.code;\n\n      if (code.indexOf('TransientError') >= 0) {\n        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n  return TransactionExecutor;\n}();\n\nexports[\"default\"] = TransactionExecutor;\n\nfunction _valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n\n  return defaultValue;\n}","map":{"version":3,"sources":["C:/Users/a1ole/Documents/GitHub/neo4jreact/node_modules/neo4j-driver/lib/internal/transaction-executor.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_classCallCheck2","_createClass2","_error","DEFAULT_MAX_RETRY_TIME_MS","DEFAULT_INITIAL_RETRY_DELAY_MS","DEFAULT_RETRY_DELAY_MULTIPLIER","DEFAULT_RETRY_DELAY_JITTER_FACTOR","TransactionExecutor","maxRetryTimeMs","initialRetryDelayMs","multiplier","jitterFactor","_maxRetryTimeMs","_valueOrDefault","_initialRetryDelayMs","_multiplier","_jitterFactor","_inFlightTimeoutIds","_verifyAfterConstruction","key","execute","transactionCreator","transactionWork","_this","Promise","resolve","reject","_executeTransactionInsidePromise","error","retryStartTimeMs","Date","now","retryDelayMs","_retryTransactionPromise","close","forEach","timeoutId","clearTimeout","retryStartTime","_this2","elapsedTimeMs","_canRetryOn","nextRetryTime","_computeDelayWithJitter","setTimeout","filter","id","push","nextRetryDelayMs","_this3","tx","resultPromise","_safeExecuteTransactionWork","then","result","_handleTransactionWorkSuccess","_handleTransactionWorkFailure","isOpen","commit","rollback","ignore","delayMs","jitter","min","max","Math","random","newError","Neo4jError","code","SERVICE_UNAVAILABLE","SESSION_EXPIRED","_isTransientError","indexOf","defaultValue"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = void 0;\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\r\n\r\nvar _error = require(\"../error\");\r\n\r\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\r\n\r\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\r\n\r\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\r\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\r\n\r\nvar TransactionExecutor =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\r\n    (0, _classCallCheck2[\"default\"])(this, TransactionExecutor);\r\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\r\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\r\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\r\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\r\n    this._inFlightTimeoutIds = [];\r\n\r\n    this._verifyAfterConstruction();\r\n  }\r\n\r\n  (0, _createClass2[\"default\"])(TransactionExecutor, [{\r\n    key: \"execute\",\r\n    value: function execute(transactionCreator, transactionWork) {\r\n      var _this = this;\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\r\n      })[\"catch\"](function (error) {\r\n        var retryStartTimeMs = Date.now();\r\n        var retryDelayMs = _this._initialRetryDelayMs;\r\n        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"close\",\r\n    value: function close() {\r\n      // cancel all existing timeouts to prevent further retries\r\n      this._inFlightTimeoutIds.forEach(function (timeoutId) {\r\n        return clearTimeout(timeoutId);\r\n      });\r\n\r\n      this._inFlightTimeoutIds = [];\r\n    }\r\n  }, {\r\n    key: \"_retryTransactionPromise\",\r\n    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\r\n      var _this2 = this;\r\n\r\n      var elapsedTimeMs = Date.now() - retryStartTime;\r\n\r\n      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {\r\n        return Promise.reject(error);\r\n      }\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);\r\n\r\n        var timeoutId = setTimeout(function () {\r\n          // filter out this timeoutId when time has come and function is being executed\r\n          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {\r\n            return id !== timeoutId;\r\n          });\r\n\r\n          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\r\n        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts\r\n\r\n        _this2._inFlightTimeoutIds.push(timeoutId);\r\n      })[\"catch\"](function (error) {\r\n        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;\r\n        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"_executeTransactionInsidePromise\",\r\n    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {\r\n      var _this3 = this;\r\n\r\n      var tx;\r\n\r\n      try {\r\n        tx = transactionCreator();\r\n      } catch (error) {\r\n        // failed to create a transaction\r\n        reject(error);\r\n        return;\r\n      }\r\n\r\n      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\r\n\r\n      resultPromise.then(function (result) {\r\n        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);\r\n      })[\"catch\"](function (error) {\r\n        return _this3._handleTransactionWorkFailure(error, tx, reject);\r\n      });\r\n    }\r\n  }, {\r\n    key: \"_safeExecuteTransactionWork\",\r\n    value: function _safeExecuteTransactionWork(tx, transactionWork) {\r\n      try {\r\n        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an\r\n        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\r\n        // validation step without type checks\r\n\r\n        return Promise.resolve(result);\r\n      } catch (error) {\r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_handleTransactionWorkSuccess\",\r\n    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {\r\n      if (tx.isOpen()) {\r\n        // transaction work returned resolved promise and transaction has not been committed/rolled back\r\n        // try to commit the transaction\r\n        tx.commit().then(function () {\r\n          // transaction was committed, return result to the user\r\n          resolve(result);\r\n        })[\"catch\"](function (error) {\r\n          // transaction failed to commit, propagate the failure\r\n          reject(error);\r\n        });\r\n      } else {\r\n        // transaction work returned resolved promise and transaction is already committed/rolled back\r\n        // return the result returned by given transaction work\r\n        resolve(result);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_handleTransactionWorkFailure\",\r\n    value: function _handleTransactionWorkFailure(error, tx, reject) {\r\n      if (tx.isOpen()) {\r\n        // transaction work failed and the transaction is still open, roll it back and propagate the failure\r\n        tx.rollback()[\"catch\"](function (ignore) {// ignore the rollback error\r\n        }).then(function () {\r\n          return reject(error);\r\n        }); // propagate the original error we got from the transaction work\r\n      } else {\r\n        // transaction is already rolled back, propagate the error\r\n        reject(error);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"_computeDelayWithJitter\",\r\n    value: function _computeDelayWithJitter(delayMs) {\r\n      var jitter = delayMs * this._jitterFactor;\r\n      var min = delayMs - jitter;\r\n      var max = delayMs + jitter;\r\n      return Math.random() * (max - min) + min;\r\n    }\r\n  }, {\r\n    key: \"_verifyAfterConstruction\",\r\n    value: function _verifyAfterConstruction() {\r\n      if (this._maxRetryTimeMs < 0) {\r\n        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\r\n      }\r\n\r\n      if (this._initialRetryDelayMs < 0) {\r\n        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\r\n      }\r\n\r\n      if (this._multiplier < 1.0) {\r\n        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\r\n      }\r\n\r\n      if (this._jitterFactor < 0 || this._jitterFactor > 1) {\r\n        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\r\n      }\r\n    }\r\n  }], [{\r\n    key: \"_canRetryOn\",\r\n    value: function _canRetryOn(error) {\r\n      return error && error instanceof _error.Neo4jError && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));\r\n    }\r\n  }, {\r\n    key: \"_isTransientError\",\r\n    value: function _isTransientError(error) {\r\n      // Retries should not happen when transaction was explicitly terminated by the user.\r\n      // Termination of transaction might result in two different error codes depending on where it was\r\n      // terminated. These are really client errors but classification on the server is not entirely correct and\r\n      // they are classified as transient.\r\n      var code = error.code;\r\n\r\n      if (code.indexOf('TransientError') >= 0) {\r\n        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {\r\n          return false;\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }]);\r\n  return TransactionExecutor;\r\n}();\r\n\r\nexports[\"default\"] = TransactionExecutor;\r\n\r\nfunction _valueOrDefault(value, defaultValue) {\r\n  if (value || value === 0) {\r\n    return value;\r\n  }\r\n\r\n  return defaultValue;\r\n}"]},"metadata":{},"sourceType":"script"}