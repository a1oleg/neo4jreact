{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.WRITE = exports.READ = exports.Driver = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"./error\");\n\nvar _connectionProvider = _interopRequireDefault(require(\"./internal/connection-provider\"));\n\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\n\nvar _connectionProviderDirect = _interopRequireDefault(require(\"./internal/connection-provider-direct\"));\n\nvar _connectivityVerifier = _interopRequireDefault(require(\"./internal/connectivity-verifier\"));\n\nvar _constants = require(\"./internal/constants\");\n\nvar _logger = _interopRequireDefault(require(\"./internal/logger\"));\n\nvar _poolConfig = require(\"./internal/pool-config\");\n\nvar _session = _interopRequireDefault(require(\"./session\"));\n\nvar _sessionRx = _interopRequireDefault(require(\"./session-rx\"));\n\nvar _requestMessage = require(\"./internal/request-message\");\n\nvar _util = require(\"./internal/util\");\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\n\n/**\r\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\r\n * @type {number}\r\n */\n\nvar DEFAULT_FETCH_SIZE = 1000;\n/**\r\n * Constant that represents read session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\r\n * @type {string}\r\n */\n\nvar READ = _constants.ACCESS_MODE_READ;\n/**\r\n * Constant that represents write session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\r\n * @type {string}\r\n */\n\nexports.READ = READ;\nvar WRITE = _constants.ACCESS_MODE_WRITE;\nexports.WRITE = WRITE;\nvar idGenerator = 0;\n/**\r\n * A driver maintains one or more {@link Session}s with a remote\r\n * Neo4j instance. Through the {@link Session}s you can send queries\r\n * and retrieve results from the database.\r\n *\r\n * Drivers are reasonably expensive to create - you should strive to keep one\r\n * driver instance around per Neo4j Instance you connect to.\r\n *\r\n * @access public\r\n */\n\nvar Driver = /*#__PURE__*/function () {\n  /**\r\n   * You should not be calling this directly, instead use {@link driver}.\r\n   * @constructor\r\n   * @protected\r\n   * @param {ServerAddress} address\r\n   * @param {string} userAgent\r\n   * @param {Object} authToken\r\n   * @param {Object} config\r\n   */\n  function Driver(address, userAgent) {\n    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    (0, _classCallCheck2[\"default\"])(this, Driver);\n    sanitizeConfig(config);\n    this._id = idGenerator++;\n    this._address = address;\n    this._userAgent = userAgent;\n    this._authToken = authToken;\n    this._config = config;\n    this._log = _logger[\"default\"].create(config);\n    /**\r\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\r\n     * @type {ConnectionProvider}\r\n     * @protected\r\n     */\n\n    this._connectionProvider = null;\n\n    this._afterConstruction();\n  }\n  /**\r\n   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\r\n   *\r\n   * @public\r\n   * @param {Object} param - The object parameter\r\n   * @param {string} param.database - The target database to verify connectivity for.\r\n   * @returns {Promise<void>} promise resolved with server info or rejected with error.\r\n   */\n\n\n  (0, _createClass2[\"default\"])(Driver, [{\n    key: \"verifyConnectivity\",\n    value: function verifyConnectivity() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$database = _ref.database,\n          database = _ref$database === void 0 ? '' : _ref$database;\n\n      var connectionProvider = this._getOrCreateConnectionProvider();\n\n      var connectivityVerifier = new _connectivityVerifier[\"default\"](connectionProvider);\n      return connectivityVerifier.verify({\n        database: database\n      });\n    }\n    /**\r\n     * Returns whether the server supports multi database capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\n\n  }, {\n    key: \"supportsMultiDb\",\n    value: function supportsMultiDb() {\n      var connectionProvider = this._getOrCreateConnectionProvider();\n\n      return connectionProvider.supportsMultiDb();\n    }\n    /**\r\n     * Returns whether the server supports transaction config capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\n\n  }, {\n    key: \"supportsTransactionConfig\",\n    value: function supportsTransactionConfig() {\n      var connectionProvider = this._getOrCreateConnectionProvider();\n\n      return connectionProvider.supportsTransactionConfig();\n    }\n    /**\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"_supportsRouting\",\n    value: function _supportsRouting() {\n      return false;\n    }\n    /**\r\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\r\n     *\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"_isEncrypted\",\n    value: function _isEncrypted() {\n      return this._config.encrypted === _util.ENCRYPTION_ON;\n    }\n    /**\r\n     * Returns the configured trust strategy that the driver has been configured with.\r\n     *\r\n     * @protected\r\n     * @returns {TrustStrategy}\r\n     */\n\n  }, {\n    key: \"_getTrust\",\n    value: function _getTrust() {\n      return this._config.trust;\n    }\n    /**\r\n     * Acquire a session to communicate with the database. The session will\r\n     * borrow connections from the underlying connection pool as required and\r\n     * should be considered lightweight and disposable.\r\n     *\r\n     * This comes with some responsibility - make sure you always call\r\n     * {@link close} when you are done using a session, and likewise,\r\n     * make sure you don't close your session before you are done using it. Once\r\n     * it is closed, the underlying connection will be released to the connection\r\n     * pool and made available for others to use.\r\n     *\r\n     * @public\r\n     * @param {Object} param - The object parameter\r\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\r\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\r\n     * @param {number} param.fetchSize - The record fetch size of each batch of this session.\r\n     * Use {@link ALL} to always pull all records in one batch. This will override the config value set on driver config.\r\n     * @param {string} param.database - The database this session will operate on.\r\n     * @return {Session} new session.\r\n     */\n\n  }, {\n    key: \"session\",\n    value: function session() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$defaultAccessMo = _ref2.defaultAccessMode,\n          defaultAccessMode = _ref2$defaultAccessMo === void 0 ? WRITE : _ref2$defaultAccessMo,\n          bookmarkOrBookmarks = _ref2.bookmarks,\n          _ref2$database = _ref2.database,\n          database = _ref2$database === void 0 ? '' : _ref2$database,\n          fetchSize = _ref2.fetchSize;\n\n      return this._newSession({\n        defaultAccessMode: defaultAccessMode,\n        bookmarkOrBookmarks: bookmarkOrBookmarks,\n        database: database,\n        reactive: false,\n        fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\n      });\n    }\n    /**\r\n     * Acquire a reactive session to communicate with the database. The session will\r\n     * borrow connections from the underlying connection pool as required and\r\n     * should be considered lightweight and disposable.\r\n     *\r\n     * This comes with some responsibility - make sure you always call\r\n     * {@link close} when you are done using a session, and likewise,\r\n     * make sure you don't close your session before you are done using it. Once\r\n     * it is closed, the underlying connection will be released to the connection\r\n     * pool and made available for others to use.\r\n     *\r\n     * @public\r\n     * @param {Object} param\r\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous transactions. Value is optional and\r\n     * absence indicates that the bookmarks do not exist or are unknown.\r\n     * @param {string} param.database - The database this session will operate on.\r\n     * @returns {RxSession} new reactive session.\r\n     */\n\n  }, {\n    key: \"rxSession\",\n    value: function rxSession() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$defaultAccessMo = _ref3.defaultAccessMode,\n          defaultAccessMode = _ref3$defaultAccessMo === void 0 ? WRITE : _ref3$defaultAccessMo,\n          bookmarks = _ref3.bookmarks,\n          _ref3$database = _ref3.database,\n          database = _ref3$database === void 0 ? '' : _ref3$database,\n          fetchSize = _ref3.fetchSize;\n\n      return new _sessionRx[\"default\"]({\n        session: this._newSession({\n          defaultAccessMode: defaultAccessMode,\n          bookmarks: bookmarks,\n          database: database,\n          reactive: true,\n          fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\n        }),\n        config: this._config\n      });\n    }\n    /**\r\n     * Close all open sessions and other associated resources. You should\r\n     * make sure to use this when you are done with this driver instance.\r\n     * @public\r\n     * @return {Promise<void>} promise resolved when the driver is closed.\r\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._log.info(\"Driver \".concat(this._id, \" closing\"));\n\n      if (this._connectionProvider) {\n        return this._connectionProvider.close();\n      }\n\n      return Promise.resolve();\n    }\n    /**\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_afterConstruction\",\n    value: function _afterConstruction() {\n      this._log.info(\"Direct driver \".concat(this._id, \" created for server address \").concat(this._address));\n    }\n    /**\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_createConnectionProvider\",\n    value: function _createConnectionProvider(address, userAgent, authToken) {\n      return new _connectionProviderDirect[\"default\"]({\n        id: this._id,\n        config: this._config,\n        log: this._log,\n        address: address,\n        userAgent: userAgent,\n        authToken: authToken\n      });\n    }\n    /**\r\n     * @protected\r\n     */\n\n  }, {\n    key: \"_newSession\",\n\n    /**\r\n     * @private\r\n     */\n    value: function _newSession(_ref4) {\n      var defaultAccessMode = _ref4.defaultAccessMode,\n          bookmarkOrBookmarks = _ref4.bookmarkOrBookmarks,\n          database = _ref4.database,\n          reactive = _ref4.reactive,\n          fetchSize = _ref4.fetchSize;\n\n      var sessionMode = Driver._validateSessionMode(defaultAccessMode);\n\n      var connectionProvider = this._getOrCreateConnectionProvider();\n\n      var bookmark = bookmarkOrBookmarks ? new _bookmark[\"default\"](bookmarkOrBookmarks) : _bookmark[\"default\"].empty();\n      return new _session[\"default\"]({\n        mode: sessionMode,\n        database: database,\n        connectionProvider: connectionProvider,\n        bookmark: bookmark,\n        config: this._config,\n        reactive: reactive,\n        fetchSize: fetchSize\n      });\n    }\n    /**\r\n     * @private\r\n     */\n\n  }, {\n    key: \"_getOrCreateConnectionProvider\",\n    value: function _getOrCreateConnectionProvider() {\n      if (!this._connectionProvider) {\n        this._connectionProvider = this._createConnectionProvider(this._address, this._userAgent, this._authToken);\n      }\n\n      return this._connectionProvider;\n    }\n  }], [{\n    key: \"_validateSessionMode\",\n    value: function _validateSessionMode(rawMode) {\n      var mode = rawMode || WRITE;\n\n      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {\n        throw (0, _error.newError)('Illegal session mode ' + mode);\n      }\n\n      return mode;\n    }\n  }]);\n  return Driver;\n}();\n/**\r\n * @private\r\n */\n\n\nexports.Driver = Driver;\n\nfunction sanitizeConfig(config) {\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);\n  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\n}\n/**\r\n * @private\r\n */\n\n\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\n  var sanitizedValue = parseInt(rawValue, 10);\n\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\n    return sanitizedValue;\n  } else if (sanitizedValue < 0) {\n    return Number.MAX_SAFE_INTEGER;\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n/**\r\n * @private\r\n */\n\n\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\n  var fetchSize = parseInt(rawValue, 10);\n\n  if (fetchSize > 0 || fetchSize === _requestMessage.ALL) {\n    return fetchSize;\n  } else if (fetchSize === 0 || fetchSize < 0) {\n    throw new Error('The fetch size can only be a positive value or -1 for ALL. However fetchSize = ' + fetchSize);\n  } else {\n    return defaultWhenAbsent;\n  }\n}\n\nvar _default = Driver;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:/Users/a1ole/Documents/GitHub/neo4jreact/node_modules/neo4j-driver/lib/driver.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","WRITE","READ","Driver","_classCallCheck2","_createClass2","_error","_connectionProvider","_bookmark","_connectionProviderDirect","_connectivityVerifier","_constants","_logger","_poolConfig","_session","_sessionRx","_requestMessage","_util","DEFAULT_MAX_CONNECTION_LIFETIME","DEFAULT_FETCH_SIZE","ACCESS_MODE_READ","ACCESS_MODE_WRITE","idGenerator","address","userAgent","authToken","arguments","length","undefined","config","sanitizeConfig","_id","_address","_userAgent","_authToken","_config","_log","create","_afterConstruction","key","verifyConnectivity","_ref","_ref$database","database","connectionProvider","_getOrCreateConnectionProvider","connectivityVerifier","verify","supportsMultiDb","supportsTransactionConfig","_supportsRouting","_isEncrypted","encrypted","ENCRYPTION_ON","_getTrust","trust","session","_ref2","_ref2$defaultAccessMo","defaultAccessMode","bookmarkOrBookmarks","bookmarks","_ref2$database","fetchSize","_newSession","reactive","validateFetchSizeValue","rxSession","_ref3","_ref3$defaultAccessMo","_ref3$database","close","info","concat","Promise","resolve","_createConnectionProvider","id","log","_ref4","sessionMode","_validateSessionMode","bookmark","empty","mode","rawMode","newError","maxConnectionLifetime","sanitizeIntValue","maxConnectionPoolSize","DEFAULT_MAX_SIZE","connectionAcquisitionTimeout","DEFAULT_ACQUISITION_TIMEOUT","rawValue","defaultWhenAbsent","sanitizedValue","parseInt","Number","MAX_SAFE_INTEGER","ALL","Error","_default"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = exports.WRITE = exports.READ = exports.Driver = void 0;\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\r\n\r\nvar _error = require(\"./error\");\r\n\r\nvar _connectionProvider = _interopRequireDefault(require(\"./internal/connection-provider\"));\r\n\r\nvar _bookmark = _interopRequireDefault(require(\"./internal/bookmark\"));\r\n\r\nvar _connectionProviderDirect = _interopRequireDefault(require(\"./internal/connection-provider-direct\"));\r\n\r\nvar _connectivityVerifier = _interopRequireDefault(require(\"./internal/connectivity-verifier\"));\r\n\r\nvar _constants = require(\"./internal/constants\");\r\n\r\nvar _logger = _interopRequireDefault(require(\"./internal/logger\"));\r\n\r\nvar _poolConfig = require(\"./internal/pool-config\");\r\n\r\nvar _session = _interopRequireDefault(require(\"./session\"));\r\n\r\nvar _sessionRx = _interopRequireDefault(require(\"./session-rx\"));\r\n\r\nvar _requestMessage = require(\"./internal/request-message\");\r\n\r\nvar _util = require(\"./internal/util\");\r\n\r\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour\r\n\r\n/**\r\n * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.\r\n * @type {number}\r\n */\r\n\r\nvar DEFAULT_FETCH_SIZE = 1000;\r\n/**\r\n * Constant that represents read session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.\r\n * @type {string}\r\n */\r\n\r\nvar READ = _constants.ACCESS_MODE_READ;\r\n/**\r\n * Constant that represents write session access mode.\r\n * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.\r\n * @type {string}\r\n */\r\n\r\nexports.READ = READ;\r\nvar WRITE = _constants.ACCESS_MODE_WRITE;\r\nexports.WRITE = WRITE;\r\nvar idGenerator = 0;\r\n/**\r\n * A driver maintains one or more {@link Session}s with a remote\r\n * Neo4j instance. Through the {@link Session}s you can send queries\r\n * and retrieve results from the database.\r\n *\r\n * Drivers are reasonably expensive to create - you should strive to keep one\r\n * driver instance around per Neo4j Instance you connect to.\r\n *\r\n * @access public\r\n */\r\n\r\nvar Driver =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * You should not be calling this directly, instead use {@link driver}.\r\n   * @constructor\r\n   * @protected\r\n   * @param {ServerAddress} address\r\n   * @param {string} userAgent\r\n   * @param {Object} authToken\r\n   * @param {Object} config\r\n   */\r\n  function Driver(address, userAgent) {\r\n    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\r\n    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n    (0, _classCallCheck2[\"default\"])(this, Driver);\r\n    sanitizeConfig(config);\r\n    this._id = idGenerator++;\r\n    this._address = address;\r\n    this._userAgent = userAgent;\r\n    this._authToken = authToken;\r\n    this._config = config;\r\n    this._log = _logger[\"default\"].create(config);\r\n    /**\r\n     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.\r\n     * @type {ConnectionProvider}\r\n     * @protected\r\n     */\r\n\r\n    this._connectionProvider = null;\r\n\r\n    this._afterConstruction();\r\n  }\r\n  /**\r\n   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.\r\n   *\r\n   * @public\r\n   * @param {Object} param - The object parameter\r\n   * @param {string} param.database - The target database to verify connectivity for.\r\n   * @returns {Promise<void>} promise resolved with server info or rejected with error.\r\n   */\r\n\r\n\r\n  (0, _createClass2[\"default\"])(Driver, [{\r\n    key: \"verifyConnectivity\",\r\n    value: function verifyConnectivity() {\r\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n          _ref$database = _ref.database,\r\n          database = _ref$database === void 0 ? '' : _ref$database;\r\n\r\n      var connectionProvider = this._getOrCreateConnectionProvider();\r\n\r\n      var connectivityVerifier = new _connectivityVerifier[\"default\"](connectionProvider);\r\n      return connectivityVerifier.verify({\r\n        database: database\r\n      });\r\n    }\r\n    /**\r\n     * Returns whether the server supports multi database capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\r\n\r\n  }, {\r\n    key: \"supportsMultiDb\",\r\n    value: function supportsMultiDb() {\r\n      var connectionProvider = this._getOrCreateConnectionProvider();\r\n\r\n      return connectionProvider.supportsMultiDb();\r\n    }\r\n    /**\r\n     * Returns whether the server supports transaction config capabilities based on the protocol\r\n     * version negotiated via handshake.\r\n     *\r\n     * Note that this function call _always_ causes a round-trip to the server.\r\n     *\r\n     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.\r\n     */\r\n\r\n  }, {\r\n    key: \"supportsTransactionConfig\",\r\n    value: function supportsTransactionConfig() {\r\n      var connectionProvider = this._getOrCreateConnectionProvider();\r\n\r\n      return connectionProvider.supportsTransactionConfig();\r\n    }\r\n    /**\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"_supportsRouting\",\r\n    value: function _supportsRouting() {\r\n      return false;\r\n    }\r\n    /**\r\n     * Returns boolean to indicate if driver has been configured with encryption enabled.\r\n     *\r\n     * @protected\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"_isEncrypted\",\r\n    value: function _isEncrypted() {\r\n      return this._config.encrypted === _util.ENCRYPTION_ON;\r\n    }\r\n    /**\r\n     * Returns the configured trust strategy that the driver has been configured with.\r\n     *\r\n     * @protected\r\n     * @returns {TrustStrategy}\r\n     */\r\n\r\n  }, {\r\n    key: \"_getTrust\",\r\n    value: function _getTrust() {\r\n      return this._config.trust;\r\n    }\r\n    /**\r\n     * Acquire a session to communicate with the database. The session will\r\n     * borrow connections from the underlying connection pool as required and\r\n     * should be considered lightweight and disposable.\r\n     *\r\n     * This comes with some responsibility - make sure you always call\r\n     * {@link close} when you are done using a session, and likewise,\r\n     * make sure you don't close your session before you are done using it. Once\r\n     * it is closed, the underlying connection will be released to the connection\r\n     * pool and made available for others to use.\r\n     *\r\n     * @public\r\n     * @param {Object} param - The object parameter\r\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous\r\n     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.\r\n     * @param {number} param.fetchSize - The record fetch size of each batch of this session.\r\n     * Use {@link ALL} to always pull all records in one batch. This will override the config value set on driver config.\r\n     * @param {string} param.database - The database this session will operate on.\r\n     * @return {Session} new session.\r\n     */\r\n\r\n  }, {\r\n    key: \"session\",\r\n    value: function session() {\r\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n          _ref2$defaultAccessMo = _ref2.defaultAccessMode,\r\n          defaultAccessMode = _ref2$defaultAccessMo === void 0 ? WRITE : _ref2$defaultAccessMo,\r\n          bookmarkOrBookmarks = _ref2.bookmarks,\r\n          _ref2$database = _ref2.database,\r\n          database = _ref2$database === void 0 ? '' : _ref2$database,\r\n          fetchSize = _ref2.fetchSize;\r\n\r\n      return this._newSession({\r\n        defaultAccessMode: defaultAccessMode,\r\n        bookmarkOrBookmarks: bookmarkOrBookmarks,\r\n        database: database,\r\n        reactive: false,\r\n        fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\r\n      });\r\n    }\r\n    /**\r\n     * Acquire a reactive session to communicate with the database. The session will\r\n     * borrow connections from the underlying connection pool as required and\r\n     * should be considered lightweight and disposable.\r\n     *\r\n     * This comes with some responsibility - make sure you always call\r\n     * {@link close} when you are done using a session, and likewise,\r\n     * make sure you don't close your session before you are done using it. Once\r\n     * it is closed, the underlying connection will be released to the connection\r\n     * pool and made available for others to use.\r\n     *\r\n     * @public\r\n     * @param {Object} param\r\n     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.\r\n     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous transactions. Value is optional and\r\n     * absence indicates that the bookmarks do not exist or are unknown.\r\n     * @param {string} param.database - The database this session will operate on.\r\n     * @returns {RxSession} new reactive session.\r\n     */\r\n\r\n  }, {\r\n    key: \"rxSession\",\r\n    value: function rxSession() {\r\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\r\n          _ref3$defaultAccessMo = _ref3.defaultAccessMode,\r\n          defaultAccessMode = _ref3$defaultAccessMo === void 0 ? WRITE : _ref3$defaultAccessMo,\r\n          bookmarks = _ref3.bookmarks,\r\n          _ref3$database = _ref3.database,\r\n          database = _ref3$database === void 0 ? '' : _ref3$database,\r\n          fetchSize = _ref3.fetchSize;\r\n\r\n      return new _sessionRx[\"default\"]({\r\n        session: this._newSession({\r\n          defaultAccessMode: defaultAccessMode,\r\n          bookmarks: bookmarks,\r\n          database: database,\r\n          reactive: true,\r\n          fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)\r\n        }),\r\n        config: this._config\r\n      });\r\n    }\r\n    /**\r\n     * Close all open sessions and other associated resources. You should\r\n     * make sure to use this when you are done with this driver instance.\r\n     * @public\r\n     * @return {Promise<void>} promise resolved when the driver is closed.\r\n     */\r\n\r\n  }, {\r\n    key: \"close\",\r\n    value: function close() {\r\n      this._log.info(\"Driver \".concat(this._id, \" closing\"));\r\n\r\n      if (this._connectionProvider) {\r\n        return this._connectionProvider.close();\r\n      }\r\n\r\n      return Promise.resolve();\r\n    }\r\n    /**\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_afterConstruction\",\r\n    value: function _afterConstruction() {\r\n      this._log.info(\"Direct driver \".concat(this._id, \" created for server address \").concat(this._address));\r\n    }\r\n    /**\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_createConnectionProvider\",\r\n    value: function _createConnectionProvider(address, userAgent, authToken) {\r\n      return new _connectionProviderDirect[\"default\"]({\r\n        id: this._id,\r\n        config: this._config,\r\n        log: this._log,\r\n        address: address,\r\n        userAgent: userAgent,\r\n        authToken: authToken\r\n      });\r\n    }\r\n    /**\r\n     * @protected\r\n     */\r\n\r\n  }, {\r\n    key: \"_newSession\",\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    value: function _newSession(_ref4) {\r\n      var defaultAccessMode = _ref4.defaultAccessMode,\r\n          bookmarkOrBookmarks = _ref4.bookmarkOrBookmarks,\r\n          database = _ref4.database,\r\n          reactive = _ref4.reactive,\r\n          fetchSize = _ref4.fetchSize;\r\n\r\n      var sessionMode = Driver._validateSessionMode(defaultAccessMode);\r\n\r\n      var connectionProvider = this._getOrCreateConnectionProvider();\r\n\r\n      var bookmark = bookmarkOrBookmarks ? new _bookmark[\"default\"](bookmarkOrBookmarks) : _bookmark[\"default\"].empty();\r\n      return new _session[\"default\"]({\r\n        mode: sessionMode,\r\n        database: database,\r\n        connectionProvider: connectionProvider,\r\n        bookmark: bookmark,\r\n        config: this._config,\r\n        reactive: reactive,\r\n        fetchSize: fetchSize\r\n      });\r\n    }\r\n    /**\r\n     * @private\r\n     */\r\n\r\n  }, {\r\n    key: \"_getOrCreateConnectionProvider\",\r\n    value: function _getOrCreateConnectionProvider() {\r\n      if (!this._connectionProvider) {\r\n        this._connectionProvider = this._createConnectionProvider(this._address, this._userAgent, this._authToken);\r\n      }\r\n\r\n      return this._connectionProvider;\r\n    }\r\n  }], [{\r\n    key: \"_validateSessionMode\",\r\n    value: function _validateSessionMode(rawMode) {\r\n      var mode = rawMode || WRITE;\r\n\r\n      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {\r\n        throw (0, _error.newError)('Illegal session mode ' + mode);\r\n      }\r\n\r\n      return mode;\r\n    }\r\n  }]);\r\n  return Driver;\r\n}();\r\n/**\r\n * @private\r\n */\r\n\r\n\r\nexports.Driver = Driver;\r\n\r\nfunction sanitizeConfig(config) {\r\n  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);\r\n  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);\r\n  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);\r\n  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\n\r\nfunction sanitizeIntValue(rawValue, defaultWhenAbsent) {\r\n  var sanitizedValue = parseInt(rawValue, 10);\r\n\r\n  if (sanitizedValue > 0 || sanitizedValue === 0) {\r\n    return sanitizedValue;\r\n  } else if (sanitizedValue < 0) {\r\n    return Number.MAX_SAFE_INTEGER;\r\n  } else {\r\n    return defaultWhenAbsent;\r\n  }\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\n\r\nfunction validateFetchSizeValue(rawValue, defaultWhenAbsent) {\r\n  var fetchSize = parseInt(rawValue, 10);\r\n\r\n  if (fetchSize > 0 || fetchSize === _requestMessage.ALL) {\r\n    return fetchSize;\r\n  } else if (fetchSize === 0 || fetchSize < 0) {\r\n    throw new Error('The fetch size can only be a positive value or -1 for ALL. However fetchSize = ' + fetchSize);\r\n  } else {\r\n    return defaultWhenAbsent;\r\n  }\r\n}\r\n\r\nvar _default = Driver;\r\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}