{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _error = require(\"./error\");\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction generateFieldLookup(keys) {\n  var lookup = {};\n  keys.forEach(function (name, idx) {\n    lookup[name] = idx;\n  });\n  return lookup;\n}\n/**\r\n * Records make up the contents of the {@link Result}, and is how you access\r\n * the output of a query. A simple query might yield a result stream\r\n * with a single record, for instance:\r\n *\r\n *     MATCH (u:User) RETURN u.name, u.age\r\n *\r\n * This returns a stream of records with two fields, named `u.name` and `u.age`,\r\n * each record represents one user found by the query above. You can access\r\n * the values of each field either by name:\r\n *\r\n *     record.get(\"u.name\")\r\n *\r\n * Or by it's position:\r\n *\r\n *     record.get(0)\r\n *\r\n * @access public\r\n */\n\n\nvar Record = /*#__PURE__*/function () {\n  /**\r\n   * Create a new record object.\r\n   * @constructor\r\n   * @protected\r\n   * @param {string[]} keys An array of field keys, in the order the fields appear in the record\r\n   * @param {Array} fields An array of field values\r\n   * @param {Object} fieldLookup An object of fieldName -> value index, used to map\r\n   *                            field names to values. If this is null, one will be\r\n   *                            generated.\r\n   */\n  function Record(keys, fields) {\n    var fieldLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    (0, _classCallCheck2[\"default\"])(this, Record);\n    /**\r\n     * Field keys, in the order the fields appear in the record.\r\n     * @type {string[]}\r\n     */\n\n    this.keys = keys;\n    /**\r\n     * Number of fields\r\n     * @type {Number}\r\n     */\n\n    this.length = keys.length;\n    this._fields = fields;\n    this._fieldLookup = fieldLookup || generateFieldLookup(keys);\n  }\n  /**\r\n   * Run the given function for each field in this record. The function\r\n   * will get three arguments - the value, the key and this record, in that\r\n   * order.\r\n   *\r\n   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.\r\n   */\n\n\n  (0, _createClass2[\"default\"])(Record, [{\n    key: \"forEach\",\n    value: function forEach(visitor) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n\n          visitor(value, key, this);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\r\n     * Run the given function for each field in this record. The function\r\n     * will get three arguments - the value, the key and this record, in that\r\n     * order.\r\n     *\r\n     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field\r\n     * and return a value that is saved to the returned Array.\r\n     *\r\n     * @returns {Array}\r\n     */\n\n  }, {\n    key: \"map\",\n    value: function map(visitor) {\n      var resultArray = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _step2$value = (0, _slicedToArray2[\"default\"])(_step2.value, 2),\n              key = _step2$value[0],\n              value = _step2$value[1];\n\n          resultArray.push(visitor(value, key, this));\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return resultArray;\n    }\n    /**\r\n     * Iterate over results. Each iteration will yield an array\r\n     * of exactly two items - the key, and the value (in order).\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Array>}\r\n     */\n\n  }, {\n    key: \"entries\",\n    value: /*#__PURE__*/_regenerator[\"default\"].mark(function entries() {\n      var i;\n      return _regenerator[\"default\"].wrap(function entries$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.keys.length)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return [this.keys[i], this._fields[i]];\n\n            case 4:\n              i++;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, entries, this);\n    })\n    /**\r\n     * Iterate over values.\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Object>}\r\n     */\n\n  }, {\n    key: \"values\",\n    value: /*#__PURE__*/_regenerator[\"default\"].mark(function values() {\n      var i;\n      return _regenerator[\"default\"].wrap(function values$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.keys.length)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 4;\n              return this._fields[i];\n\n            case 4:\n              i++;\n              _context2.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, values, this);\n    })\n    /**\r\n     * Iterate over values. Delegates to {@link Record#values}\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Object>}\r\n     */\n\n  }, {\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regenerator[\"default\"].mark(function value() {\n      return _regenerator[\"default\"].wrap(function value$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.delegateYield(this.values(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, value, this);\n    })\n    /**\r\n     * Generates an object out of the current Record\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      var object = {};\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = (0, _slicedToArray2[\"default\"])(_step3.value, 2),\n              key = _step3$value[0],\n              _value = _step3$value[1];\n\n          object[key] = _value;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return object;\n    }\n    /**\r\n     * Get a value from this record, either by index or by field key.\r\n     *\r\n     * @param {string|Number} key Field key, or the index of the field.\r\n     * @returns {*}\r\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var index;\n\n      if (!(typeof key === 'number')) {\n        index = this._fieldLookup[key];\n\n        if (index === undefined) {\n          throw (0, _error.newError)(\"This record has no field with key '\" + key + \"', available key are: [\" + this.keys + '].');\n        }\n      } else {\n        index = key;\n      }\n\n      if (index > this._fields.length - 1 || index < 0) {\n        throw (0, _error.newError)(\"This record has no field with index '\" + index + \"'. Remember that indexes start at `0`, \" + 'and make sure your query returns records in the shape you meant it to.');\n      }\n\n      return this._fields[index];\n    }\n    /**\r\n     * Check if a value from this record, either by index or by field key, exists.\r\n     *\r\n     * @param {string|Number} key Field key, or the index of the field.\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      // if key is a number, we check if it is in the _fields array\n      if (typeof key === 'number') {\n        return key >= 0 && key < this._fields.length;\n      } // if it's not a number, we check _fieldLookup dictionary directly\n\n\n      return this._fieldLookup[key] !== undefined;\n    }\n  }]);\n  return Record;\n}();\n\nvar _default = Record;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["C:/Users/a1ole/Documents/GitHub/neo4jreact/node_modules/neo4j-driver/lib/record.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","_regenerator","_slicedToArray2","_classCallCheck2","_createClass2","_error","generateFieldLookup","keys","lookup","forEach","name","idx","Record","fields","fieldLookup","arguments","length","undefined","_fields","_fieldLookup","key","visitor","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","entries","Symbol","iterator","_step","next","done","_step$value","err","map","resultArray","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_step2$value","push","mark","i","wrap","entries$","_context","prev","stop","values","values$","_context2","value$","_context3","delegateYield","toObject","object","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_step3$value","_value","get","index","newError","has","_default"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = void 0;\r\n\r\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\r\n\r\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\r\n\r\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\r\n\r\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\r\n\r\nvar _error = require(\"./error\");\r\n\r\n/**\r\n * Copyright (c) 2002-2020 \"Neo4j,\"\r\n * Neo4j Sweden AB [http://neo4j.com]\r\n *\r\n * This file is part of Neo4j.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction generateFieldLookup(keys) {\r\n  var lookup = {};\r\n  keys.forEach(function (name, idx) {\r\n    lookup[name] = idx;\r\n  });\r\n  return lookup;\r\n}\r\n/**\r\n * Records make up the contents of the {@link Result}, and is how you access\r\n * the output of a query. A simple query might yield a result stream\r\n * with a single record, for instance:\r\n *\r\n *     MATCH (u:User) RETURN u.name, u.age\r\n *\r\n * This returns a stream of records with two fields, named `u.name` and `u.age`,\r\n * each record represents one user found by the query above. You can access\r\n * the values of each field either by name:\r\n *\r\n *     record.get(\"u.name\")\r\n *\r\n * Or by it's position:\r\n *\r\n *     record.get(0)\r\n *\r\n * @access public\r\n */\r\n\r\n\r\nvar Record =\r\n/*#__PURE__*/\r\nfunction () {\r\n  /**\r\n   * Create a new record object.\r\n   * @constructor\r\n   * @protected\r\n   * @param {string[]} keys An array of field keys, in the order the fields appear in the record\r\n   * @param {Array} fields An array of field values\r\n   * @param {Object} fieldLookup An object of fieldName -> value index, used to map\r\n   *                            field names to values. If this is null, one will be\r\n   *                            generated.\r\n   */\r\n  function Record(keys, fields) {\r\n    var fieldLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\r\n    (0, _classCallCheck2[\"default\"])(this, Record);\r\n\r\n    /**\r\n     * Field keys, in the order the fields appear in the record.\r\n     * @type {string[]}\r\n     */\r\n    this.keys = keys;\r\n    /**\r\n     * Number of fields\r\n     * @type {Number}\r\n     */\r\n\r\n    this.length = keys.length;\r\n    this._fields = fields;\r\n    this._fieldLookup = fieldLookup || generateFieldLookup(keys);\r\n  }\r\n  /**\r\n   * Run the given function for each field in this record. The function\r\n   * will get three arguments - the value, the key and this record, in that\r\n   * order.\r\n   *\r\n   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.\r\n   */\r\n\r\n\r\n  (0, _createClass2[\"default\"])(Record, [{\r\n    key: \"forEach\",\r\n    value: function forEach(visitor) {\r\n      var _iteratorNormalCompletion = true;\r\n      var _didIteratorError = false;\r\n      var _iteratorError = undefined;\r\n\r\n      try {\r\n        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\r\n          var _step$value = (0, _slicedToArray2[\"default\"])(_step.value, 2),\r\n              key = _step$value[0],\r\n              value = _step$value[1];\r\n\r\n          visitor(value, key, this);\r\n        }\r\n      } catch (err) {\r\n        _didIteratorError = true;\r\n        _iteratorError = err;\r\n      } finally {\r\n        try {\r\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\r\n            _iterator[\"return\"]();\r\n          }\r\n        } finally {\r\n          if (_didIteratorError) {\r\n            throw _iteratorError;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Run the given function for each field in this record. The function\r\n     * will get three arguments - the value, the key and this record, in that\r\n     * order.\r\n     *\r\n     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field\r\n     * and return a value that is saved to the returned Array.\r\n     *\r\n     * @returns {Array}\r\n     */\r\n\r\n  }, {\r\n    key: \"map\",\r\n    value: function map(visitor) {\r\n      var resultArray = [];\r\n      var _iteratorNormalCompletion2 = true;\r\n      var _didIteratorError2 = false;\r\n      var _iteratorError2 = undefined;\r\n\r\n      try {\r\n        for (var _iterator2 = this.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\r\n          var _step2$value = (0, _slicedToArray2[\"default\"])(_step2.value, 2),\r\n              key = _step2$value[0],\r\n              value = _step2$value[1];\r\n\r\n          resultArray.push(visitor(value, key, this));\r\n        }\r\n      } catch (err) {\r\n        _didIteratorError2 = true;\r\n        _iteratorError2 = err;\r\n      } finally {\r\n        try {\r\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\r\n            _iterator2[\"return\"]();\r\n          }\r\n        } finally {\r\n          if (_didIteratorError2) {\r\n            throw _iteratorError2;\r\n          }\r\n        }\r\n      }\r\n\r\n      return resultArray;\r\n    }\r\n    /**\r\n     * Iterate over results. Each iteration will yield an array\r\n     * of exactly two items - the key, and the value (in order).\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Array>}\r\n     */\r\n\r\n  }, {\r\n    key: \"entries\",\r\n    value:\r\n    /*#__PURE__*/\r\n    _regenerator[\"default\"].mark(function entries() {\r\n      var i;\r\n      return _regenerator[\"default\"].wrap(function entries$(_context) {\r\n        while (1) {\r\n          switch (_context.prev = _context.next) {\r\n            case 0:\r\n              i = 0;\r\n\r\n            case 1:\r\n              if (!(i < this.keys.length)) {\r\n                _context.next = 7;\r\n                break;\r\n              }\r\n\r\n              _context.next = 4;\r\n              return [this.keys[i], this._fields[i]];\r\n\r\n            case 4:\r\n              i++;\r\n              _context.next = 1;\r\n              break;\r\n\r\n            case 7:\r\n            case \"end\":\r\n              return _context.stop();\r\n          }\r\n        }\r\n      }, entries, this);\r\n    })\r\n    /**\r\n     * Iterate over values.\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Object>}\r\n     */\r\n\r\n  }, {\r\n    key: \"values\",\r\n    value:\r\n    /*#__PURE__*/\r\n    _regenerator[\"default\"].mark(function values() {\r\n      var i;\r\n      return _regenerator[\"default\"].wrap(function values$(_context2) {\r\n        while (1) {\r\n          switch (_context2.prev = _context2.next) {\r\n            case 0:\r\n              i = 0;\r\n\r\n            case 1:\r\n              if (!(i < this.keys.length)) {\r\n                _context2.next = 7;\r\n                break;\r\n              }\r\n\r\n              _context2.next = 4;\r\n              return this._fields[i];\r\n\r\n            case 4:\r\n              i++;\r\n              _context2.next = 1;\r\n              break;\r\n\r\n            case 7:\r\n            case \"end\":\r\n              return _context2.stop();\r\n          }\r\n        }\r\n      }, values, this);\r\n    })\r\n    /**\r\n     * Iterate over values. Delegates to {@link Record#values}\r\n     *\r\n     * @generator\r\n     * @returns {IterableIterator<Object>}\r\n     */\r\n\r\n  }, {\r\n    key: Symbol.iterator,\r\n    value:\r\n    /*#__PURE__*/\r\n    _regenerator[\"default\"].mark(function value() {\r\n      return _regenerator[\"default\"].wrap(function value$(_context3) {\r\n        while (1) {\r\n          switch (_context3.prev = _context3.next) {\r\n            case 0:\r\n              return _context3.delegateYield(this.values(), \"t0\", 1);\r\n\r\n            case 1:\r\n            case \"end\":\r\n              return _context3.stop();\r\n          }\r\n        }\r\n      }, value, this);\r\n    })\r\n    /**\r\n     * Generates an object out of the current Record\r\n     *\r\n     * @returns {Object}\r\n     */\r\n\r\n  }, {\r\n    key: \"toObject\",\r\n    value: function toObject() {\r\n      var object = {};\r\n      var _iteratorNormalCompletion3 = true;\r\n      var _didIteratorError3 = false;\r\n      var _iteratorError3 = undefined;\r\n\r\n      try {\r\n        for (var _iterator3 = this.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\r\n          var _step3$value = (0, _slicedToArray2[\"default\"])(_step3.value, 2),\r\n              key = _step3$value[0],\r\n              _value = _step3$value[1];\r\n\r\n          object[key] = _value;\r\n        }\r\n      } catch (err) {\r\n        _didIteratorError3 = true;\r\n        _iteratorError3 = err;\r\n      } finally {\r\n        try {\r\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\r\n            _iterator3[\"return\"]();\r\n          }\r\n        } finally {\r\n          if (_didIteratorError3) {\r\n            throw _iteratorError3;\r\n          }\r\n        }\r\n      }\r\n\r\n      return object;\r\n    }\r\n    /**\r\n     * Get a value from this record, either by index or by field key.\r\n     *\r\n     * @param {string|Number} key Field key, or the index of the field.\r\n     * @returns {*}\r\n     */\r\n\r\n  }, {\r\n    key: \"get\",\r\n    value: function get(key) {\r\n      var index;\r\n\r\n      if (!(typeof key === 'number')) {\r\n        index = this._fieldLookup[key];\r\n\r\n        if (index === undefined) {\r\n          throw (0, _error.newError)(\"This record has no field with key '\" + key + \"', available key are: [\" + this.keys + '].');\r\n        }\r\n      } else {\r\n        index = key;\r\n      }\r\n\r\n      if (index > this._fields.length - 1 || index < 0) {\r\n        throw (0, _error.newError)(\"This record has no field with index '\" + index + \"'. Remember that indexes start at `0`, \" + 'and make sure your query returns records in the shape you meant it to.');\r\n      }\r\n\r\n      return this._fields[index];\r\n    }\r\n    /**\r\n     * Check if a value from this record, either by index or by field key, exists.\r\n     *\r\n     * @param {string|Number} key Field key, or the index of the field.\r\n     * @returns {boolean}\r\n     */\r\n\r\n  }, {\r\n    key: \"has\",\r\n    value: function has(key) {\r\n      // if key is a number, we check if it is in the _fields array\r\n      if (typeof key === 'number') {\r\n        return key >= 0 && key < this._fields.length;\r\n      } // if it's not a number, we check _fieldLookup dictionary directly\r\n\r\n\r\n      return this._fieldLookup[key] !== undefined;\r\n    }\r\n  }]);\r\n  return Record;\r\n}();\r\n\r\nvar _default = Record;\r\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}